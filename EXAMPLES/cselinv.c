/**********************************************************************
***********************************************************************

   Version:        0.1
   Last modified:  Sep 13, 2011
   Authors:        
     Chao Yang,
     Computer Research Division, Lawrence Berkeley National Lab
     Lin Lin,
     Computer Research Division, Lawrence Berkeley National Lab

***********************************************************************
***********************************************************************

     cselinv.c is the driver routine that computes the selected
     inversion of a sparse, symmetric, nonsingular linear system based
     on its sparse ldl' factorization. In particular, the diagonal
     elements are saved. 

     Usage: cselinv.x -file=<filename> -order=<n> -chkerr=1\n");
     -file	:   Input file name. This file should should have the 
		    extension ".ccf" and this format can be generated by
		    convertmat.x under the directory UTILITIES/.
		    Matrix Market (MM) format is supported there.

     -order     :   Reordering strategy:
		    order = -1 (default) : Multiple Minimum Degree Reordering.
		    If METIS is supported, then the following choices
		    are also available:
		    order = 2 : Node Nested Dissection
		    order = 3 : Edge Nested Dissection

     -chkerr    :   Whether full inversion is to be computed for
		    efficiency comparison.  
		    chkerr = 0 (default). Only perform selected inversion.
		    chkerr = 1. Both selected inversion and full
    		      inversion are computed.


***********************************************************************
**********************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <unistd.h>
#include <time.h>


typedef struct { double r, i; } doublecomplex;


#define nzvals(i) nzvals[(i)-1]
#define rowind(i) rowind[(i)-1]
#define colptr(i) colptr[(i)-1]
#define xsol(i)   xsol[(i)-1]
#define rhs(i)    rhs[(i)-1]
#define diag(i)   diag[(i)-1]
#define diag2(i)  diag2[(i)-1]
#define rowind_inva(i) rowind_inva[(i)-1]
#define colptr_inva(i) colptr_inva[(i)-1]
#define inva(i) inva[(i)-1]

extern int ldlt_preprocess__(int *, int *, int *, int *, int *, int *, int *);
extern int ldlt_fact__(int *, int *, int *, doublecomplex *);
extern int ldlt_solve__(int *, doublecomplex *, doublecomplex *);
extern int ldlt_free__(int *);
extern int ldlt_blkselinv__(int *, int*, int*, doublecomplex *, int*);

extern int readmatrixheader_(char *, int *, int *);
extern int readcmatrix_(char *, int *, int *, doublecomplex *);
#ifdef __DEBUG
extern double getime(void);
#endif

int main(int argc, char ** argv)
{
   int i, j, nnodes,nedges, ia, nnz, ibeg, iend ;
   int nx= -1, ny = -1, count, node;
   int *perm;
   int *rowind, *colptr;
   doublecomplex *nzvals, *rhs, *xsol, *diag, *diag2;
   int token, order=-1;
   int Lnnz;
   double t0,t1, errmax; 
   long myclktck;
   double dval;
   double errabs;
   int chkerr = 0,  dumpL=0;
   int ierr = 0;
   char filename[120];
   int* rowind_inva;
   int* colptr_inva;
   doublecomplex* inva;
   FILE* fid;
   
   ia = 1;
   if( argc == 1 ){
     fprintf(stderr, "invalide argument!\n");
     fprintf(stderr, "usage: selinv.x -file=<filename> -order=<-1|2|3> -chkerr=<0|1>\n");
     fprintf(stderr, "\n");
     fprintf(stderr, "For example, if the selected inversion of Harwell-Boeing matrix bcsstk14 is to be\n");
     fprintf(stderr, "computed, Multiple Minimum Degree reordering is used and full inversion is also \n");
     fprintf(stderr, "calculated for efficiency comparison, run\n");
     fprintf(stderr, "selinv.x -file=bcsstk14.ccf -order=-1 -chkerr=1\n");

     return 1;
   }

   while (ia < argc) {
      if ( !strncmp(argv[ia],"-file",5) ) {
	 strcpy(filename,&argv[ia][6]);
      }
      else if ( !strncmp(argv[ia],"-order",6) ) {
    	 order = atoi(&argv[ia][7]);
      }
      else if ( !strncmp(argv[ia],"-chkerr",7) ) {
    	 chkerr = atoi(&argv[ia][8]);
         if (chkerr != 0) chkerr = 1;
      }
      else {
 	 fprintf(stderr, "invalide argument!\n");
	 fprintf(stderr, "usage: selinvmain -file=<filename> -order=<-1|2|3> -chkerr=<0|1>\n");
         return 1;
      }
      ia++;
   }

   nnodes = 0;
   nnz = 0;
   

   readmatrixheader_(filename, &nnodes, &nnz);

   colptr = (int*)malloc((nnodes+1)*sizeof(int));
   rowind = (int*)malloc(nnz*sizeof(int));
   nzvals = (doublecomplex*)malloc(nnz*sizeof(doublecomplex));

   readcmatrix_(filename, colptr, rowind, nzvals);
   /*
   for(i = 0; i < nnz; i++){
     printf("nzvals[%d] = (%15.5e, %15.5e)\n", i, nzvals[i].r,
	    nzvals[i].i);
   }
   */

   token = 0;
  
   perm = NULL;   /* perm is not used here*/
   ldlt_preprocess__(&token, &nnodes, colptr, rowind, &Lnnz, &order, perm);   
   printf(" NUMBER OF ROWS IN A = %d\n", nnodes);
   printf(" NUMBER OF NONZERO ELEMENTS IN A = %d\n" , nnz);
   printf(" NUMBER OF NONZERO ELEMENTS IN L = %d\n\n", Lnnz); 

   ldlt_fact__(&token, colptr, rowind, nzvals);

   rhs = (doublecomplex*)calloc(nnodes,sizeof(doublecomplex));
   xsol = (doublecomplex*)calloc(nnodes,sizeof(doublecomplex));
   diag = (doublecomplex*)malloc(nnodes*sizeof(doublecomplex));

   if (chkerr) {
      /* obtain the diagonal of inverse using the "slow" way, i.e. the
       * full inversion is calculated */
#ifdef __DEBUG
      t0 = getime();
#endif
      for (i=1; i<=nnodes; i++) {
         rhs(i).r = 1.0;
	 rhs(i).i = 0.0;
         ldlt_solve__(&token, xsol, rhs);
         diag(i).r = xsol(i).r;
	 diag(i).i = xsol(i).i;
	 // printf("diag(i) = %11.3e  xsol(i) = %11.3e\n", diag(i), xsol(i));
         rhs(i).r = 0.0;
	 rhs(i).i = 0.0;
      } 
      // ldlt_diaginv__(&token, diag); 
#ifdef __DEBUG
      t1 = getime();
      printf(" TIME FOR FULL INVERSION = %11.3e\n", (t1-t0));
#endif
#ifdef __DEBUG
      for (i=1; i<=nnodes; i++) {
	fprintf(stderr,"diag[%4d] = %25.15f\n", i, diag(i));
      }
#endif
   }

   /* selected inversion */
   colptr_inva = (int*)malloc(sizeof(int)*(nnodes+1));
   rowind_inva = (int*)malloc(sizeof(int)*Lnnz);
   inva  = (doublecomplex*) malloc(sizeof(doublecomplex)*Lnnz);
   ldlt_blkselinv__(&token, colptr_inva, rowind_inva, inva, &dumpL);

   diag2 = (doublecomplex*)calloc(nnodes,sizeof(doublecomplex));
   for(j = 1; j < nnodes+1; j++){
     for(i = colptr_inva(j); i < colptr_inva(j+1); i++){
       if(rowind_inva(i) == j){
	 diag2(j) = inva(i);
       }
     }
   }


   if (chkerr) {
      errmax = 0.0;
      for (i=1; i<=nnodes; i++) {
          errabs = fabs(diag(i).r-diag2(i).r) + fabs(diag(i).i-diag2(i).i);
          if ( errabs > errmax )
              errmax = fabs(diag(i).r-diag2(i).r)
		     + fabs(diag(i).i-diag2(i).i) ; 
      }
      printf(" ERROR OF THE DIAGONAL ELEMENTS BETWEEN FULL INVERSION AND SELECTED INVERSION = %11.3e\n", errmax);
   }


   /* Output the elements of invA */
   fid = fopen("invA", "w");
   for(j = 1; j < nnodes+1; j++){
     for(i = colptr_inva(j); i < colptr_inva(j+1); i++){
       fprintf(fid, "%5d %5d %25.15e %25.15e\n", 
	       rowind_inva(i), j, inva(i).r, inva(i).i);
     }
   }
   fclose(fid);

   ldlt_free__(&token); 

   if (order == 0) free(perm);
   free(colptr); 
   free(rowind); 
   free(nzvals); 
   free(rhs); 
   free(xsol); 
   free(diag); 
   free(diag2); 
   free(colptr_inva);
   free(rowind_inva);
   free(inva);
}
